## Notes for Splunk Threat Hunting

Started by opening the console from the web and logging in to the splunk as Admin

The task advises to run

```
index=* | stats count by index
```

```
index=* | stats count by sourcetype index
```

First task is to find the IP address of the internal host infected with Gh0st RAT malware

### Thought Process

The only actionable information provided in the scenario that can aid in starting the investigation is that there is a suspected Gh0st RAT malware infection.

Intrusion detection signatures for Gh0st RAT are widely available and enabled by default in most rule sets. Suricata IDS logs were provided as a source. Therefore, analyzing these logs is a logical place to begin the investigation. The network diragram shows the location of two sensors named `onion-fn1` and `onion-fn2`, which generate the Zeek and Suricata logs. These logs have been ingested in Splunk.

The advisory now makes sense. It's useful to understand how the log sources were ingested, and which indexes they are stored in.

We can query for logs from suricata and just search *gh0st*.

```
index=* sourcetype=suricata gh0st
```

And we get suricata alert logs indicating Gh0st RAT infection of an IP address 172.16.6.104 (HR Department according to the network diagram).

We can see if there are other infected hosts by adding a NOT operator and giving it the IP address we identified.

The first alert came in 6/22/23 10:14:57 indicating compromise

Another more effective way of determining the infected hosts goes like this.

Querying splunk indexes/sourcetypes:

```
index=* | stats count by index sourcetype
```

The query data shows the Suricata logs are stored in the index named `suricata`.

Looking at suricata logs:
```
index=suricata
```

The query shows thousands of logs entries. In order to more effectively analyze them, they need to be further reduced. The hosts field shows that there are two hosts that generated Suricata logs, `onion-fn1` and `onion-fn2`. The network diagram shows that `onion-fn1` monitors the network perimeter. Logs generated by `onion-fn1` are therefore most likely to help provide the IP address of the internal host.

The following Splunk query shows all Suricata logs generated by `onion-fn1`.

```
index=suricata host=onion-fn1
```

While filtering on events generated only by `onion-fn1` reduced the log count by more than half, it is still too many entries for manual analysis. A technique called stack counting, or long tail analysis, can be used to further reduce the log count by focusing on a single interesting field. In this case the field called `"alert.signature"` appears to provide a short description of what triggered the IDS alert. This field is a good candidate for stack counting.

The following Splunk query shows only the `alert.signature` fields generated by `onion-fn1`:

```
index=suricata host=onion-fn1| stats count by alert.signature
```

The filtered logs can be seearch for evidence of Gh0st RAT

Fields for source and destination IP can be added to the final query output.

The following Splunk query searches for alerts containing the string `Gh0st`, and extracts fields such as the timestamp, alert signature, source IP and destination IP:

```
index=suricata host=onion-fn1 Gh0st | stats count by alert.signature src_ip dest_ip
```

This reveals that the potentially infected host IP address is `172.16.6.104` which is communicating with the external IP address `119.28.139.120`

### Hunting Initial Execution

Now we have enough information to identify malicious processes and activities performed by the attackers.

We have Sysmon logs which are ideal for identifying such events.

Sysmon logs have EventCode fields which say what action was performed.

First we have to identify the infected hostname. To do that we can look at the network diagram, but what if we didn't have a network diagram?

We can look for Sysmon EventCode 22 which is DNS queries.

```
index=windows EventCode=22 172.16.6.104
```

Now that we know the hostname we can tune our searches for that exact host with `host="hostname"`

Next we want to find the process that made a network connection to the identified malicious IP (119.28.139.120).

To do that we can use EventCode 3 which is Network Connections

```
index=windows host="hostname" EventCode=3 119.28.139.120
```

First log is almost at the same time as the suricata detection.

We get a ProcessId, which we can use to further dive into child processes and other activities.

Looking for EventCode 1 which is execution, with the ProcessId we get the filename path, the user and the ParentCommandLine, and identify the malicious stager.

Then we can look at all the processes which have ParentImage set to the stager.

```
index=windows host="hostname" EventCode=1 ParentImage="C:\\<path-to-image>"
```

First we find a cmd child process, which is a parent process for a powershell process which executes the malicious .exe file.

Looking at network logs we see that it also makes a connection to our proxy server. Looking at the proxy server logs with compromised source ip and source port we see the original filename which was downloaded and a domain name which we can now flag as malicious.
